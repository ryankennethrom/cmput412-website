{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-my-cmput-412-website","title":"Welcome to my CMPUT 412 Website","text":""},{"location":"#reports","title":"Reports","text":"<ol> <li>Exercise 1 Report</li> <li>Exercise 2 Report</li> </ol>"},{"location":"#other-links","title":"Other Links","text":"<p>CMPUT 412 Repo</p>"},{"location":"ex1/","title":"Exercise 1","text":""},{"location":"ex1/#exercise-1-report","title":"Exercise 1 Report","text":""},{"location":"ex1/#dashboard-camera-and-motor-signals","title":"Dashboard camera and motor signals","text":"<p>Below shows an image and a video of the dashboard showing camera and motor signals of our duckiebot. We see that the camera and motors seem to respond to our inputs. The next step is to calibrate them. The purpose of calibrating camera and motors is to account for manufacturing inconsistencies. Just because there is inaccurate output when controlling the duckiebot doesn't mean that it is unusable. We can fix the inconsistencies through manual calibration to some extent. </p>"},{"location":"ex1/#dashboard-screenshot","title":"Dashboard Screenshot","text":""},{"location":"ex1/#dashboard-video","title":"Dashboard Video","text":""},{"location":"ex1/#calibrating-the-camera","title":"Calibrating the Camera","text":"<p>Calibrating the camera makes sure that the robot receive accurate representation of its environment. The duckiebot's camera calibration is simplified and only needed us to move the robot's position and camera angles with respect to an image designed for calibrating it. After calibrating the camera, the robot generated the following files.</p>"},{"location":"ex1/#camera-intrinsic-yaml","title":"camera intrinsic yaml","text":""},{"location":"ex1/#camera-extrinsic-yaml","title":"camera extrinsic yaml","text":""},{"location":"ex1/#calibrating-the-wheels","title":"Calibrating the Wheels","text":"<p>We calibrated our duckiebot's wheels by repeatedly setting different values to its gain and trim parameters in the terminal. Below shows the contents of our kinematics .yaml file showing these parameters and their calibrated values.</p> <p></p>"},{"location":"ex1/#driving-in-a-straight-line","title":"Driving in a Straight Line","text":"<p>After calibrating the wheels, we achieved a close enough result in making the robot drive in a straight line for 2 meters while only holding down the forward key. It was especially hard to figure out how to correctly set the parameters to keep the duckiebot dead center. After discussing with the TAs, we realized it might be because of the uneven platform beneath the robot. One way to fix this is to increase the gain parameter increasing the average speed of the robot.</p> <p></p>"},{"location":"ex1/#lane-following","title":"Lane Following","text":"<p>The duckiebot provides an easy to setup lane following demo. We only needed to place the duckiebot on the right side of a particularly designed lane and after some commands in the terminal, we pressed \"a\" to start the demo. We initially had a hiccup in this part since when we started the demo it moved only a few centimeters before stopping completely. After increasing the gain from 1.0 to 2.0, we are able to achieve a pretty good result.</p> <p></p>"},{"location":"ex1/#running-a-python-program-in-the-robot","title":"Running a python program in the robot","text":"<p>One main and very useful features of docker is for quick and easy recreation of environments that our programs are built and expected to work on. After finishing writing the program for the duckiebot, we used two docker commands to build our program and run it on the robot itself. It is a simple python program that prints \"Hello from csc22909!\"</p> <p></p>"},{"location":"ex1/#references","title":"References","text":"<p>Duckietown Documentation</p> <p>Project Partner: Abdullah Khadeli at akhadeli@ualberta.ca</p>"},{"location":"ex2/","title":"Exercise 2","text":""},{"location":"ex2/#exercise-2-report","title":"Exercise 2 Report","text":""},{"location":"ex2/#what-is-a-ros-node-and-what-is-its-role-in-the-ros-ecosystem","title":"What is a ROS node, and what is its role in the ROS ecosystem ?","text":"<p>Ros is a distributed framework of processes (aka Nodes) that enables executables to be individually designed and loosely coupled at runtime. </p> <p>A package may contain ROS runtime processes (nodes).</p> <p>Nodes are processes that perform computation. Ros is designed to be modular at a fined-grained scale; a robot control system usually comprises many nodes. For example, one node controls a laser range-finder, one node controls the wheel motors, one node performs localization, one node performs path planning, one Node provides a graphical view of the system, and so on. A ROS node is written with the use of a ROS client library, such as roscpp or rospy.</p>"},{"location":"ex2/#what-are-ros-topics-and-how-do-they-facilitate-communication-between-nodes","title":"What are ROS topics, and how do they facilitate communication between nodes ?","text":"<p>Messages are routed via a transport system with publish / subscribe semantics. A node sends out a message by publishing it to a given topic. The topic is a name that is used to identify the content of the message. A node that is interested in a certain kind of data will subcribe to the appropriate topic. There may be multiple concurrent publishers and subscribers for a single topic, and a single node may publish and/or subscribe to multiple topics. In general, publishers and subscribers are not aware of each other's existence. The ideas is to decouple the production of information from its consumption. Logically, one can think of a topic as a strongly typed message bus. Each bus has a name, and anyone can connect to the bus to send or receive messages as long as they are the right type.</p>"},{"location":"ex2/#what-are-ros-services-and-how-do-they-differ-from-topics","title":"What are ROS services, and how do they differ from topics ?","text":"<p>Service descriptions, stored in my_package/srv/MyServiceType.srv, define the request and response data structures for messages sent in ROS.</p> <p>The publish / subscribe model is a very flexible communication paradigm, but its many-to-many , one-way transport is not appropriate for request / reply interactions, which are often required in a distributed system. Request / reply is done via services, which are defined by a pair of message structures: one for the request and one for the reply. A providing node offers a service under a name and a client uses the service by sending the request message and awaiting the reply. ROS client libraries generally present this interaction to the programmer as if it were a remote procedure call.</p>"},{"location":"ex2/#what-are-ros-messages-and-how-are-they-structured-for-communication","title":"What are ROS messages, and how are they structured for communication ?","text":"<p>Message descriptions, stored in my_package/msg/MyMessageType.msg, define the data structures for messages sent in ROS.</p> <p>Nodes communicate with each other by passing messages. A message is simply a data structure, comprising typed fields. Standard primitive types (integer, floating point, boolean, etc.) are supported, as are arrays of primitive types. Messages can include arbitrarily nested structures and arrays (much like C structs).</p>"},{"location":"ex2/#what-is-a-ros-bag-and-how-is-it-used-in-data-recording-and-playback","title":"What is a ROS bag, and how is it used in data recording and playback ?","text":"<p>Bags are a format for saving and playing back ROS message data. Bags are an important mechanism for storing data, such as sensor data, that can be difficult to collect but is necessary for developing and testing algorithms.</p>"}]}